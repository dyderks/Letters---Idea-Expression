<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Musical Water Ripples</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(circle at center, #003366 0%, #000814 100%);
    font-family: sans-serif;
  }
  h1 {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    text-shadow: 0 0 10px #000;
    z-index: 10;
  }
  .info {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: rgba(255,255,255,0.7);
    font-size: 14px;
    text-align: center;
    z-index: 10;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
  <h1>Musical Water Ripples</h1>
  <div class="info">Welcome to the symphony of the ocean!</div>
  <canvas id="pond"></canvas>
  <script>
    const canvas = document.getElementById('pond');
    const ctx = canvas.getContext('2d');
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });
    
    const ripples = [];
    
    // Audio context for generating sounds
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Musical notes (frequencies in Hz)
    const notes = {
      A: 261.63, // C4
      B: 293.66, // D4
      C: 329.63, // E4
      D: 349.23, // F4
      E: 392.00, // G4
      F: 440.00, // A4
      G: 493.88, // B4
      H: 523.25, // C5
      I: 587.33, // D5
      J: 659.25, // E5
      K: 698.46, // F5
      L: 783.99, // G5
      M: 880.00, // A5
      N: 987.77, // B5
      O: 1046.50, // C6
      P: 293.66, // D4
      Q: 329.63, // E4
      R: 349.23, // F4
      S: 392.00, // G4
      T: 440.00, // A4
      U: 493.88, // B4
      V: 523.25, // C5
      W: 587.33, // D5
      X: 659.25, // E5
      Y: 698.46, // F5
      Z: 783.99  // G5
    };
    
    // Different ripple configurations for each key
    const rippleTypes = {
      A: { color: 'rgba(255,100,100', speed: 2, intensity: 0.9, rings: 3, pattern: 'burst' },
      B: { color: 'rgba(255,150,100', speed: 2.5, intensity: 0.8, rings: 5, pattern: 'smooth' },
      C: { color: 'rgba(255,200,100', speed: 3, intensity: 0.7, rings: 4, pattern: 'ripple' },
      D: { color: 'rgba(255,255,100', speed: 2.2, intensity: 0.85, rings: 6, pattern: 'wave' },
      E: { color: 'rgba(200,255,100', speed: 2.8, intensity: 0.75, rings: 5, pattern: 'burst' },
      F: { color: 'rgba(100,255,100', speed: 3.2, intensity: 0.8, rings: 4, pattern: 'smooth' },
      G: { color: 'rgba(100,255,200', speed: 2.6, intensity: 0.9, rings: 7, pattern: 'ripple' },
      H: { color: 'rgba(100,255,255', speed: 2.4, intensity: 0.7, rings: 5, pattern: 'wave' },
      I: { color: 'rgba(100,200,255', speed: 2.9, intensity: 0.85, rings: 4, pattern: 'burst' },
      J: { color: 'rgba(100,150,255', speed: 3.1, intensity: 0.75, rings: 6, pattern: 'smooth' },
      K: { color: 'rgba(100,100,255', speed: 2.3, intensity: 0.8, rings: 5, pattern: 'ripple' },
      L: { color: 'rgba(150,100,255', speed: 2.7, intensity: 0.9, rings: 4, pattern: 'wave' },
      M: { color: 'rgba(200,100,255', speed: 3.0, intensity: 0.7, rings: 7, pattern: 'burst' },
      N: { color: 'rgba(255,100,255', speed: 2.5, intensity: 0.85, rings: 5, pattern: 'smooth' },
      O: { color: 'rgba(255,100,200', speed: 2.8, intensity: 0.75, rings: 6, pattern: 'ripple' },
      P: { color: 'rgba(255,150,150', speed: 2.4, intensity: 0.8, rings: 4, pattern: 'wave' },
      Q: { color: 'rgba(150,255,150', speed: 2.6, intensity: 0.9, rings: 5, pattern: 'burst' },
      R: { color: 'rgba(150,150,255', speed: 3.2, intensity: 0.7, rings: 6, pattern: 'smooth' },
      S: { color: 'rgba(255,255,150', speed: 2.2, intensity: 0.85, rings: 4, pattern: 'ripple' },
      T: { color: 'rgba(150,255,255', speed: 2.9, intensity: 0.75, rings: 7, pattern: 'wave' },
      U: { color: 'rgba(255,150,255', speed: 2.7, intensity: 0.8, rings: 5, pattern: 'burst' },
      V: { color: 'rgba(200,200,100', speed: 2.5, intensity: 0.9, rings: 4, pattern: 'smooth' },
      W: { color: 'rgba(100,200,200', speed: 3.0, intensity: 0.7, rings: 6, pattern: 'ripple' },
      X: { color: 'rgba(200,100,200', speed: 2.8, intensity: 0.85, rings: 5, pattern: 'wave' },
      Y: { color: 'rgba(255,200,150', speed: 2.3, intensity: 0.75, rings: 4, pattern: 'burst' },
      Z: { color: 'rgba(150,200,255', speed: 3.1, intensity: 0.8, rings: 7, pattern: 'smooth' },
      default: { color: 'rgba(0,150,255', speed: 2.5, intensity: 0.7, rings: 5, pattern: 'ripple' }
    };
    
    // Play sound for the key
    function playSound(frequency, duration = 0.5) {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = 'sine';
      
      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration);
    }
    
    // Play a chord (multiple notes at once)
    function playChord(frequencies, duration = 0.8) {
      frequencies.forEach(freq => {
        playSound(freq, duration);
      });
    }
    
    // Easter egg: Wave effect
    function triggerWave() {
      playChord([261.63, 329.63, 392.00, 493.88, 659.25], 1.5);
      
      const waveConfig = {
        color: 'rgba(100,200,255',
        speed: 4,
        intensity: 1.1,
        rings: 10,
        pattern: 'wave'
      };
      
      // Create a wave that sweeps across the screen
      for (let i = 0; i < 15; i++) {
        setTimeout(() => {
          const x = (i / 14) * width;
          const y = height / 2 + Math.sin(i * 0.5) * 100;
          ripples.push(new Ripple(x, y, waveConfig));
        }, i * 80);
      }
    }
    
    // Easter egg: Storm effect
    function triggerStorm() {
      playChord([392.00, 523.25, 659.25], 0.3);
      
      const stormDuration = 3000; // 3 seconds
      const interval = 150;
      let elapsed = 0;
      
      const stormInterval = setInterval(() => {
        if (elapsed >= stormDuration) {
          clearInterval(stormInterval);
          return;
        }
        
        // Random ripple
        const x = Math.random() * width;
        const y = Math.random() * height;
        const randomLetter = String.fromCharCode(65 + Math.floor(Math.random() * 26));
        const config = rippleTypes[randomLetter] || rippleTypes.default;
        
        ripples.push(new Ripple(x, y, config));
        
        // Random sound
        const randomNote = Object.values(notes)[Math.floor(Math.random() * 26)];
        playSound(randomNote, 0.2);
        
        elapsed += interval;
      }, interval);
    }
    
    // Easter egg: Current effect
    function triggerCurrent() {
      playChord([261.63, 293.66, 329.63], 2.0);
      
      const currentConfig = {
        color: 'rgba(50,150,255',
        speed: 3,
        intensity: 0.8,
        rings: 8,
        pattern: 'wave'
      };
      
      // Create horizontal flowing current
      const numWaves = 5;
      for (let wave = 0; wave < numWaves; wave++) {
        for (let i = 0; i < 20; i++) {
          setTimeout(() => {
            const x = (i / 19) * width;
            const y = (wave / numWaves) * height + height * 0.1;
            ripples.push(new Ripple(x, y, currentConfig));
          }, i * 50 + wave * 200);
        }
      }
    }
    
    // Easter egg: Tsunami effect
    function triggerTsunami() {
      playChord([130.81, 164.81, 196.00], 3.0); // Deep low notes
      
      const tsunamiConfig = {
        color: 'rgba(0,100,200',
        speed: 6,
        intensity: 1.5,
        rings: 15,
        pattern: 'wave'
      };
      
      // Giant wave sweeping across
      for (let i = 0; i < 25; i++) {
        setTimeout(() => {
          const x = (i / 24) * width;
          // Create multiple vertical ripples for height
          for (let j = 0; j < 3; j++) {
            const y = height * 0.3 + j * 50 + Math.sin(i * 0.3) * 80;
            ripples.push(new Ripple(x, y, tsunamiConfig));
          }
        }, i * 60);
      }
    }
    
    // Easter egg: Tornado effect
    function triggerTornado() {
      playChord([440.00, 554.37, 659.25, 880.00], 2.5);
      
      const tornadoConfig = {
        color: 'rgba(150,150,255',
        speed: 3.5,
        intensity: 1.0,
        rings: 7,
        pattern: 'burst'
      };
      
      const centerX = width / 2;
      const centerY = height / 2;
      const numRipples = 40;
      const spiralTurns = 4;
      
      // Create spiral pattern
      for (let i = 0; i < numRipples; i++) {
        setTimeout(() => {
          const angle = (i / numRipples) * Math.PI * 2 * spiralTurns;
          const radius = (i / numRipples) * Math.min(width, height) * 0.4;
          const x = centerX + Math.cos(angle) * radius;
          const y = centerY + Math.sin(angle) * radius;
          ripples.push(new Ripple(x, y, tornadoConfig));
        }, i * 40);
      }
    }
    
    // Easter egg: Deep effect
    function triggerDeep() {
      // Very low, deep notes
      playChord([65.41, 82.41, 98.00], 2.5);
      
      const deepConfig = {
        color: 'rgba(10,20,60',
        speed: 2,
        intensity: 1.2,
        rings: 12,
        pattern: 'smooth'
      };
      
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Create expanding dark ripples from center
      for (let i = 0; i < 8; i++) {
        setTimeout(() => {
          ripples.push(new Ripple(centerX, centerY, deepConfig));
        }, i * 150);
      }
    }
    
    // Easter egg: Coral effect
    function triggerCoral() {
      playChord([523.25, 659.25, 783.99, 1046.50], 2.0);
      
      const coralConfig = {
        color: 'rgba(255,200,100',
        speed: 1.8,
        intensity: 0.9,
        rings: 10,
        pattern: 'burst'
      };
      
      // Create coral-like branching pattern
      const centerX = width / 2;
      const centerY = height * 0.7;
      const branches = 8;
      
      for (let branch = 0; branch < branches; branch++) {
        const angle = (branch / branches) * Math.PI * 2;
        
        for (let i = 0; i < 6; i++) {
          setTimeout(() => {
            const distance = i * 40;
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance - i * 20;
            ripples.push(new Ripple(x, y, coralConfig));
            
            // Add sub-branches
            if (i > 2) {
              const subAngle1 = angle + 0.5;
              const subAngle2 = angle - 0.5;
              const subDist = 25;
              
              ripples.push(new Ripple(
                x + Math.cos(subAngle1) * subDist, 
                y + Math.sin(subAngle1) * subDist, 
                coralConfig
              ));
              ripples.push(new Ripple(
                x + Math.cos(subAngle2) * subDist, 
                y + Math.sin(subAngle2) * subDist, 
                coralConfig
              ));
            }
          }, branch * 100 + i * 120);
        }
      }
    }
    
    class Ripple {
      constructor(x, y, config) {
        this.x = x;
        this.y = y;
        this.time = 0;
        this.maxTime = 180;
        this.color = config.color;
        this.speed = config.speed;
        this.intensity = config.intensity;
        this.pattern = config.pattern;
        this.isReverse = config.speed < 0; // Check if reverse ripple
        this.rings = [];
        
        // For reverse ripples, start with max radius
        if (this.isReverse) {
          this.startRadius = 300;
        }
        
        // Create rings based on configuration
        for (let i = 0; i < config.rings; i++) {
          this.rings.push({
            delay: i * (this.pattern === 'burst' ? 4 : 8),
            offset: i * 0.3
          });
        }
      }
      
      update() {
        this.time++;
      }
      
      draw() {
        this.rings.forEach(ring => {
          const ringTime = this.time - ring.delay;
          if (ringTime < 0) return;
          
          const ringProgress = ringTime / this.maxTime;
          
          // Calculate radius (reverse ripples contract inward)
          let radius;
          if (this.isReverse) {
            radius = this.startRadius - (ringTime * Math.abs(this.speed));
            if (radius <= 0) return;
          } else {
            radius = ringTime * this.speed;
          }
          
          // Different alpha decay based on pattern
          let alpha;
          switch(this.pattern) {
            case 'reverse':
              alpha = Math.max(0, ringProgress * this.intensity * 1.2);
              break;
            case 'burst':
              alpha = Math.max(0, (1 - ringProgress * 1.5) * this.intensity);
              break;
            case 'smooth':
              alpha = Math.max(0, (1 - ringProgress) * this.intensity * Math.exp(-ringProgress * 1.5));
              break;
            case 'wave':
              alpha = Math.max(0, (1 - ringProgress) * this.intensity * (1 + Math.sin(ringProgress * Math.PI * 4) * 0.3));
              break;
            default: // ripple
              alpha = Math.max(0, (1 - ringProgress) * this.intensity * Math.exp(-ringProgress * 2));
          }
          
          // Different amplitude based on pattern
          let amplitude;
          switch(this.pattern) {
            case 'reverse':
              amplitude = 3 * ringProgress * Math.sin(ringProgress * Math.PI);
              break;
            case 'burst':
              amplitude = 4 * (1 - ringProgress) * Math.sin(ringProgress * Math.PI * 2);
              break;
            case 'smooth':
              amplitude = 2 * (1 - ringProgress);
              break;
            case 'wave':
              amplitude = 3 * (1 - ringProgress) * Math.abs(Math.sin(ringProgress * Math.PI * 6));
              break;
            default: // ripple
              amplitude = 3 * (1 - ringProgress) * Math.sin(ringProgress * Math.PI);
          }
          
          // Draw main ring (ensure radius is positive)
          if (radius > 0) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = `${this.color},${alpha * 0.8})`;
            ctx.lineWidth = Math.max(0.5, amplitude);
            ctx.stroke();
          }
          
          // Add highlights and shadows for depth
          if (amplitude > 1 && radius > amplitude * 0.5) {
            const innerRadius = radius - amplitude * 0.5;
            const outerRadius = radius + amplitude * 0.5;
            
            if (innerRadius > 0) {
              ctx.beginPath();
              ctx.arc(this.x, this.y, innerRadius, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.3})`;
              ctx.lineWidth = 1;
              ctx.stroke();
            }
            
            if (outerRadius > 0) {
              ctx.beginPath();
              ctx.arc(this.x, this.y, outerRadius, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(0,0,50,${alpha * 0.4})`;
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        });
      }
      
      isDead() {
        return this.time >= this.maxTime;
      }
    }
    
    // Easter egg tracking
    let easterEggSequence = '';
    let easterEggTimeout = null;
    
    // Create ripple when a letter is pressed
    document.addEventListener('keydown', e => {
      const letter = e.key.toUpperCase();
      
      // Handle spacebar - massive splash
      if (e.key === ' ') {
        e.preventDefault();
        playChord([261.63, 329.63, 392.00, 523.25]); // C major chord
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Create multiple ripples in a circle pattern
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const distance = 100;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          
          setTimeout(() => {
            const config = { 
              color: 'rgba(255,255,255', 
              speed: 3.5, 
              intensity: 1.0, 
              rings: 6, 
              pattern: 'burst' 
            };
            ripples.push(new Ripple(x, y, config));
          }, i * 30);
        }
        
        // Center explosion
        const config = { 
          color: 'rgba(255,200,100', 
          speed: 4, 
          intensity: 1.2, 
          rings: 8, 
          pattern: 'burst' 
        };
        ripples.push(new Ripple(centerX, centerY, config));
        return;
      }
      
      if (!/^[A-Z]$/.test(letter)) return;
      
      // Track easter egg sequences
      easterEggSequence += letter;
      clearTimeout(easterEggTimeout);
      easterEggTimeout = setTimeout(() => {
        easterEggSequence = '';
      }, 1000);
      
      // Check for easter eggs
      if (easterEggSequence.includes('TSUNAMI')) {
        triggerTsunami();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('TORNADO')) {
        triggerTornado();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('CURRENT')) {
        triggerCurrent();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('CORAL')) {
        triggerCoral();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('WAVE')) {
        triggerWave();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('STORM')) {
        triggerStorm();
        easterEggSequence = '';
        return;
      }
      
      if (easterEggSequence.includes('DEEP')) {
        triggerDeep();
        easterEggSequence = '';
        return;
      }
      
      // Play sound
      const frequency = notes[letter];
      playSound(frequency);
      
      const config = rippleTypes[letter] || rippleTypes.default;
      
      // Random position for each drop
      const x = Math.random() * width;
      const y = Math.random() * height * 0.7 + height * 0.15;
      
      ripples.push(new Ripple(x, y, config));
    });
    
    // Click to create ripples (with shift modifier for reverse ripples)
    canvas.addEventListener('click', e => {
      // Play middle C for clicks
      playSound(523.25);
      
      let config;
      
      // Reverse ripple with shift key
      if (e.shiftKey) {
        config = {
          color: 'rgba(255,100,255',
          speed: -2.5, // Negative speed for reverse effect
          intensity: 0.9,
          rings: 6,
          pattern: 'reverse'
        };
      } else {
        config = rippleTypes.default;
      }
      
      ripples.push(new Ripple(e.clientX, e.clientY, config));
    });
    
    function animate() {
      // Gentle fade for trail effect
      ctx.fillStyle = 'rgba(0, 20, 50, 0.15)';
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw all ripples
      for (let i = ripples.length - 1; i >= 0; i--) {
        ripples[i].update();
        ripples[i].draw();
        
        if (ripples[i].isDead()) {
          ripples.splice(i, 1);
        }
      }
      
      requestAnimationFrame(animate);
    }
    
    animate();
  </script>
</body>
</html>